ミニKVストア 設計案

インメモリ（HashMap）を基本とし、主に「データ型」と「エラー処理」の複雑度で3つの案を作成しま
した。

【案1：初級】まずは動かす、シンプル案

- データ型: HashMap<String, String>
  - キーも値も String に限定します。最も直感的で、最初のステップとして最適です。
- エラー処理: Option<T> または Result<T, Box<dyn std::error::Error>>
  - Rustの基本的なエラー処理方法を使います。まずはエラーが起こる可能性を意識することから
    始めます。
- メリット:
  - 実装がシンプルで、KVストアの基本的な動作（SET, GET, DELETE）の実現に集中できます。
  - Rustの標準ライブラリの知識で完結できます。
- デメリット:
  - 保存できるのが文字列だけなので、数値などを扱うには型変換が必要です。
  - エラーの種類が区別しづらく、詳細な原因究明が難しい場合があります。

【案2：中級】より実践的に、独自型を導入する案

- データ型: HashMap<String, Value>
  - 値を表現する独自の enum Value { String(String), Integer(i64) }
    のような型を定義します。これにより、複数のデータ型を統一的に扱えるようになります。
- エラー処理: Result<T, KvError>
  - enum KvError { KeyNotFound, InvalidCommand, ... }
    のように、プロジェクト固有のエラー型を定義します。これにより、エラーの種類に応じたき
    め細やかな対応が可能になります。
- メリット:
  - より多くのデータ型を扱える、実践的なアプリケーションに近い形になります。
  - enum の設計を通じて、Rustらしい型システムの理解が深まります。
  - エラーハンドリングが明確になり、テストも書きやすくなります。
- デメリット:
  - 案1に比べて、最初に定義すべき型が増えるため、少し複雑になります。

【案3：上級】汎用性と拡張性を追求する案

- データ型: HashMap<String, Vec<u8>>
  - 値をバイト配列 (Vec<u8>)
    で保持します。あらゆるデータをバイナリとして格納し、取り出す際にデシリアライズ（復元
    ）します。
- エラー処理: thiserror クレートなどを活用した高度なエラーハンドリング
  - パースエラー、I/Oエラーなど、エラーの発生源ごとに型を分け、ライブラリを使って定型的な
    実装を自動化します。
- メリット:
  - 文字列や数値だけでなく、構造体や画像など、あらゆるデータを保存できる究極の汎用性を持
    ちます。
  - シリアライズの概念を学ぶことができ、永続化（ファイル保存）やネットワーク通信への拡張
    が容易になります。
  - 将来的なDocker化を見据えた場合、データのポータビリティが非常に高くなります。
- デメリット:
  - シリアライズ/デシリアライズの処理が必須となり、実装の複雑度が最も高くなります。
  - serde などの外部ライブラリの理解が必要になります。
